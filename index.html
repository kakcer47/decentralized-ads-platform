<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DecentralNet</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 0; background: #f4f4f4; }
        .container { max-width: 800px; margin: 0 auto; padding: 20px; }
        .header { display: flex; justify-content: space-between; align-items: center; }
        .nav { display: flex; gap: 20px; }
        .nav a { text-decoration: none; color: #333; padding: 8px 12px; border-radius: 4px; }
        .nav a:hover { background: #e0e0e0; }
        .nav a.active { font-weight: bold; background: #007bff; color: white; }
        .stats { display: flex; gap: 20px; margin: 20px 0; }
        .stat-item { background: white; padding: 10px; border-radius: 4px; border: 1px solid #ddd; }
        .post-form, .post { border: 1px solid #ddd; padding: 15px; margin: 10px 0; background: white; border-radius: 4px; }
        .post-form textarea { width: 100%; height: 80px; margin-bottom: 10px; padding: 8px; border-radius: 4px; border: 1px solid #ddd; }
        .post-form select, .post-form button { margin-right: 10px; padding: 8px 12px; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background: white; padding: 20px; border-radius: 8px; max-width: 500px; width: 90%; }
        .modal-content button { margin: 5px; padding: 8px 16px; }
        .modal-content textarea { width: 100%; height: 100px; margin: 10px 0; }
        .error { color: red; margin: 10px 0; }
        .success { color: green; margin: 10px 0; }
        .post { box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .post-meta { color: #666; font-size: 0.9em; margin-bottom: 8px; }
        .post-content { margin: 10px 0; }
        .post-signature { font-size: 0.8em; color: #888; }
        #network-status { padding: 4px 8px; border-radius: 4px; font-size: 0.9em; }
        .status-connected { background: #d4edda; color: #155724; }
        .status-error { background: #f8d7da; color: #721c24; }
        .status-connecting { background: #fff3cd; color: #856404; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>DecentralNet</h1>
            <div>
                <div id="user-status">Анонимный пользователь</div>
                <div id="network-status" class="status-connecting">Подключение...</div>
            </div>
        </div>
        
        <div class="nav">
            <a href="#" class="active" onclick="showTab('feed')">Лента</a>
            <a href="#" onclick="showTab('rooms')">Комнаты</a>
            <a href="#" onclick="showTab('profile')">Профиль</a>
            <a href="#" onclick="showTab('settings')">Настройки</a>
        </div>
        
        <div class="stats">
            <div class="stat-item">Участников: <span id="peers-count">0</span></div>
            <div class="stat-item">Постов: <span id="posts-count">0</span></div>
            <div class="stat-item">Синхр.: <span id="sync-status">Ожидание</span></div>
        </div>
        
        <div id="error-display" class="error" style="display: none;"></div>
        <div id="success-display" class="success" style="display: none;"></div>
        
        <div id="feed" class="tab-content">
            <div class="post-form">
                <textarea id="post-content" placeholder="Что у вас нового?"></textarea>
                <div>
                    <select id="post-duration">
                        <option value="permanent">Постоянный пост</option>
                        <option value="1h">1 час</option>
                        <option value="1d">1 день</option>
                        <option value="1w">1 неделя</option>
                        <option value="1m">1 месяц</option>
                    </select>
                    <button onclick="publishPost()">Опубликовать</button>
                </div>
            </div>
            <div id="posts"></div>
        </div>
        
        <div id="rooms" class="tab-content" style="display: none;">
            <h3>Комнаты чата</h3>
            <p>Функция комнат находится в разработке. Скоро здесь можно будет создавать тематические группы для общения.</p>
        </div>
        
        <div id="profile" class="tab-content" style="display: none;">
            <h3>Профиль пользователя</h3>
            <p>Настройка профиля находится в разработке.</p>
        </div>
        
        <div id="settings" class="tab-content" style="display: none;">
            <h3>Настройки</h3>
            <button onclick="showModal('login')">Вход/Регистрация</button>
            <button onclick="showModal('export')" id="export-btn" disabled>Экспорт ключей</button>
            <br><br>
            <button onclick="clearData()">Очистить данные</button>
        </div>
    </div>

    <!-- Модальные окна -->
    <div id="login-modal" class="modal">
        <div class="modal-content">
            <h2>Вход в DecentralNet</h2>
            <p>Создайте новый аккаунт или импортируйте существующий ключ для подписи постов.</p>
            <button onclick="createAccount()">Создать новый аккаунт</button>
            <button onclick="showModal('import')">Импортировать ключ</button>
            <button onclick="closeModal('login')">Закрыть</button>
        </div>
    </div>
    
    <div id="import-modal" class="modal">
        <div class="modal-content">
            <h2>Импорт ключей</h2>
            <textarea id="import-key" placeholder="Вставьте приватный ключ в формате JSON"></textarea>
            <input type="file" id="key-file" accept=".txt,.json">
            <br><br>
            <button onclick="importKey()">Импортировать</button>
            <button onclick="closeModal('import')">Отмена</button>
            <div id="import-error" class="error" style="display: none;"></div>
        </div>
    </div>
    
    <div id="export-modal" class="modal">
        <div class="modal-content">
            <h2>Ваши ключи доступа</h2>
            <p>Сохраните этот ключ в безопасном месте. Он нужен для восстановления доступа к аккаунту.</p>
            <textarea id="private-key" readonly></textarea>
            <br>
            <button onclick="copyKey()">Копировать ключ</button>
            <button onclick="downloadKey()">Скачать файл</button>
            <button onclick="closeModal('export')">Закрыть</button>
            <div id="copy-success" class="success" style="display: none;">Ключ скопирован!</div>
        </div>
    </div>

    <script>
        // Конфигурация узла
        const nodeConfig = {
            id: crypto.randomUUID(),
            level: 2,
            capacity: 1,
            trust: 0.5,
            connections: new Set(),
            data_cache: new Map()
        };

        // Глобальные переменные
        let db;
        let cryptoKey;
        let isConnected = false;

        // Инициализация IndexedDB
        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('DecentralNet', 1);
                
                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    if (!db.objectStoreNames.contains('posts')) {
                        db.createObjectStore('posts', { keyPath: 'id' });
                    }
                    if (!db.objectStoreNames.contains('keys')) {
                        db.createObjectStore('keys', { keyPath: 'id' });
                    }
                };
                
                request.onsuccess = (event) => {
                    db = event.target.result;
                    resolve();
                };
                
                request.onerror = (event) => {
                    showError('Ошибка инициализации базы данных');
                    reject(event.target.error);
                };
            });
        }

        // Генерация ключевой пары
        async function generateKeyPair() {
            try {
                cryptoKey = await crypto.subtle.generateKey(
                    { name: 'ECDSA', namedCurve: 'P-256' },
                    true,
                    ['sign', 'verify']
                );
                
                const exportedKey = await crypto.subtle.exportKey('jwk', cryptoKey.privateKey);
                const keyString = JSON.stringify(exportedKey, null, 2);
                
                document.getElementById('private-key').value = keyString;
                document.getElementById('user-status').textContent = 'Зарегистрированный пользователь';
                document.getElementById('export-btn').disabled = false;
                
                // Сохранить ключ в локальном хранилище
                await saveKeyToStorage(exportedKey);
                
                showSuccess('Аккаунт успешно создан!');
            } catch (error) {
                showError('Ошибка создания ключей: ' + error.message);
            }
        }

        // Сохранение ключа в IndexedDB
        async function saveKeyToStorage(key) {
            try {
                const tx = db.transaction(['keys'], 'readwrite');
                const store = tx.objectStore('keys');
                await store.put({ id: 'current', key: key });
            } catch (error) {
                console.error('Error saving key:', error);
            }
        }

        // Загрузка ключа из хранилища
        async function loadKeyFromStorage() {
            try {
                const tx = db.transaction(['keys'], 'readonly');
                const store = tx.objectStore('keys');
                const request = store.get('current');
                
                return new Promise((resolve) => {
                    request.onsuccess = async () => {
                        if (request.result) {
                            try {
                                cryptoKey = await crypto.subtle.importKey(
                                    'jwk',
                                    request.result.key,
                                    { name: 'ECDSA', namedCurve: 'P-256' },
                                    true,
                                    ['sign']
                                );
                                document.getElementById('user-status').textContent = 'Зарегистрированный пользователь';
                                document.getElementById('export-btn').disabled = false;
                            } catch (error) {
                                console.error('Error importing stored key:', error);
                            }
                        }
                        resolve();
                    };
                    request.onerror = () => resolve();
                });
            } catch (error) {
                console.error('Error loading key:', error);
            }
        }

        // Импорт ключа
        async function importKey() {
            let keyText = document.getElementById('import-key').value.trim();
            
            // Если нет текста, попробуем загрузить из файла
            if (!keyText) {
                const fileInput = document.getElementById('key-file');
                if (fileInput.files.length > 0) {
                    try {
                        keyText = await fileInput.files[0].text();
                    } catch (error) {
                        showImportError('Ошибка чтения файла');
                        return;
                    }
                }
            }
            
            if (!keyText) {
                showImportError('Вставьте ключ или выберите файл');
                return;
            }
            
            try {
                const keyData = JSON.parse(keyText);
                cryptoKey = await crypto.subtle.importKey(
                    'jwk',
                    keyData,
                    { name: 'ECDSA', namedCurve: 'P-256' },
                    true,
                    ['sign']
                );
                
                await saveKeyToStorage(keyData);
                document.getElementById('user-status').textContent = 'Зарегистрированный пользователь';
                document.getElementById('export-btn').disabled = false;
                
                closeModal('import');
                showSuccess('Ключ успешно импортирован!');
            } catch (error) {
                showImportError('Неверный формат ключа: ' + error.message);
            }
        }

        // Публикация поста
        async function publishPost() {
            if (!cryptoKey) {
                showError('Войдите или зарегистрируйтесь для публикации');
                return;
            }
            
            const content = document.getElementById('post-content').value.trim();
            if (!content) {
                showError('Введите текст поста');
                return;
            }
            
            try {
                const duration = document.getElementById('post-duration').value;
                const post = {
                    id: crypto.randomUUID(),
                    content,
                    duration,
                    timestamp: Date.now(),
                    author: nodeConfig.id
                };
                
                // Подписать пост
                const signature = await crypto.subtle.sign(
                    { name: 'ECDSA', hash: 'SHA-256' },
                    cryptoKey.privateKey,
                    new TextEncoder().encode(JSON.stringify(post))
                );
                post.signature = Array.from(new Uint8Array(signature));
                
                await storePost(post);
                renderPosts();
                document.getElementById('post-content').value = '';
                showSuccess('Пост опубликован!');
            } catch (error) {
                showError('Ошибка публикации: ' + error.message);
            }
        }

        // Сохранение поста
        async function storePost(post) {
            const tx = db.transaction(['posts'], 'readwrite');
            const store = tx.objectStore('posts');
            store.put(post);
            nodeConfig.data_cache.set(post.id, post);
            updateStats();
        }

        // Отображение постов
        async function renderPosts() {
            try {
                const tx = db.transaction(['posts'], 'readonly');
                const store = tx.objectStore('posts');
                const request = store.getAll();
                
                request.onsuccess = () => {
                    const posts = request.result.sort((a, b) => b.timestamp - a.timestamp);
                    document.getElementById('posts-count').textContent = posts.length;
                    
                    const postsHtml = posts.map(post => `
                        <div class="post">
                            <div class="post-meta">
                                <strong>Пользователь ${post.author.slice(0, 8)}</strong> 
                                • ${new Date(post.timestamp).toLocaleString()}
                                • ${post.duration === 'permanent' ? 'Постоянный' : post.duration}
                            </div>
                            <div class="post-content">${escapeHtml(post.content)}</div>
                            <div class="post-signature">${post.signature ? '✓ Подписан' : '⚠ Без подписи'}</div>
                        </div>
                    `).join('');
                    
                    document.getElementById('posts').innerHTML = postsHtml || '<p>Постов пока нет. Создайте первый!</p>';
                };
            } catch (error) {
                showError('Ошибка загрузки постов: ' + error.message);
            }
        }

        // Вспомогательные функции
        function showTab(tab) {
            document.querySelectorAll('.tab-content').forEach(el => el.style.display = 'none');
            document.querySelectorAll('.nav a').forEach(el => el.classList.remove('active'));
            document.getElementById(tab).style.display = 'block';
            document.querySelector(`.nav a[onclick="showTab('${tab}')"]`).classList.add('active');
            if (tab === 'feed') renderPosts();
        }

        function showModal(modalId) {
            closeAllModals();
            document.getElementById(`${modalId}-modal`).style.display = 'flex';
        }

        function closeModal(modalId) {
            document.getElementById(`${modalId}-modal`).style.display = 'none';
        }

        function closeAllModals() {
            document.querySelectorAll('.modal').forEach(modal => modal.style.display = 'none');
        }

        async function copyKey() {
            try {
                const keyText = document.getElementById('private-key').value;
                await navigator.clipboard.writeText(keyText);
                document.getElementById('copy-success').style.display = 'block';
                setTimeout(() => {
                    document.getElementById('copy-success').style.display = 'none';
                }, 3000);
            } catch (error) {
                showError('Ошибка копирования: ' + error.message);
            }
        }

        function downloadKey() {
            const key = document.getElementById('private-key').value;
            const blob = new Blob([key], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'decentralnet-private-key.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function updateStats() {
            document.getElementById('peers-count').textContent = nodeConfig.connections.size;
            document.getElementById('sync-status').textContent = isConnected ? 'OK' : 'Локально';
        }

        async function createAccount() {
            closeModal('login');
            await generateKeyPair();
            showModal('export');
        }

        function clearData() {
            if (confirm('Удалить все данные? Это действие нельзя отменить.')) {
                const request = indexedDB.deleteDatabase('DecentralNet');
                request.onsuccess = () => {
                    location.reload();
                };
            }
        }

        function showError(message) {
            const errorDiv = document.getElementById('error-display');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => errorDiv.style.display = 'none', 5000);
        }

        function showSuccess(message) {
            const successDiv = document.getElementById('success-display');
            successDiv.textContent = message;
            successDiv.style.display = 'block';
            setTimeout(() => successDiv.style.display = 'none', 3000);
        }

        function showImportError(message) {
            const errorDiv = document.getElementById('import-error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Инициализация при загрузке
        window.onload = async () => {
            try {
                await initDB();
                await loadKeyFromStorage();
                
                // Имитация сетевого подключения (пока без реального P2P)
                setTimeout(() => {
                    const statusEl = document.getElementById('network-status');
                    statusEl.textContent = 'Локальный режим';
                    statusEl.className = 'status-connected';
                    isConnected = false;
                    updateStats();
                }, 2000);
                
                renderPosts();
                showSuccess('DecentralNet запущен в локальном режиме');
            } catch (error) {
                showError('Ошибка инициализации: ' + error.message);
            }
        };

        // Закрытие модальных окон по клику вне них
        window.onclick = (event) => {
            if (event.target.classList.contains('modal')) {
                event.target.style.display = 'none';
            }
        };
    </script>
</body>
</html>
